"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fetch_1 = __importDefault(require("node-fetch"));
class VultrexHaste {
    constructor(options) {
        this.url = options ? `${options.url}/documents` : "https://hastebin.com/documents";
    }
    /**
     * POST to a Hastebin URL and return the URL
     *
     * @param { string } content - The content of what you wish to post to Hastebin
     * @returns { string } - The URL of the created Haste
     *
     * @example
     * const { VultrexHaste } = require("vultrex.haste");
     * const haste = new VultrexHaste({ url: "https://hastebin.com" });
     *
     * haste.post("Lorem ipsum")
     *      .then(url => console.log(url))
     *      .catch(err => console.log(err));
     */
    async post(content) {
        const res = await node_fetch_1.default(this.url, {
            method: "POST",
            body: content
        });
        if (res.status === 200) {
            const json = await res.json();
            return `${this.url.slice(0, -10)}/${json.key}`;
        }
        return res.statusText;
    }
    /**
     * GET from a Hastebin URL and return the content
     *
     * @param { string } url - The URL of the Haste
     * @returns { string } - The content of the URL
     *
     * @example
     * const { VultrexHaste } = require("vultrex.haste");
     * const haste = new VultrexHaste();
     *
     * haste.get("https://hastebin.com/foradowute")
     *      .then(content => console.log(content))
     *      .catch(err => console.log(err));
     */
    async get(url) {
        const res = await node_fetch_1.default(url);
        return res.text();
    }
}
exports.VultrexHaste = VultrexHaste;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSw0REFBK0I7QUFNL0IsTUFBYSxZQUFZO0lBRXJCLFlBQW1CLE9BQTRCO1FBQzNDLElBQUksQ0FBQyxHQUFHLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsZ0NBQWdDLENBQUM7SUFDdkYsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7O09BYUc7SUFDSSxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQWU7UUFDN0IsTUFBTSxHQUFHLEdBQUcsTUFBTSxvQkFBSyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDOUIsTUFBTSxFQUFFLE1BQU07WUFDZCxJQUFJLEVBQUUsT0FBTztTQUNoQixDQUFDLENBQUM7UUFFSCxJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssR0FBRyxFQUFFO1lBQ3BCLE1BQU0sSUFBSSxHQUFHLE1BQU0sR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQzlCLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDbEQ7UUFFRCxPQUFPLEdBQUcsQ0FBQyxVQUFVLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7O09BYUc7SUFDSSxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQVc7UUFDeEIsTUFBTSxHQUFHLEdBQUcsTUFBTSxvQkFBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzdCLE9BQU8sR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ3RCLENBQUM7Q0FDSjtBQXBERCxvQ0FvREMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZmV0Y2ggZnJvbSBcIm5vZGUtZmV0Y2hcIjtcblxuaW50ZXJmYWNlIFZ1bHRyZXhIYXN0ZU9wdGlvbnMge1xuICAgIHVybD86IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIFZ1bHRyZXhIYXN0ZSB7XG4gICAgcHJpdmF0ZSB1cmw6IHN0cmluZztcbiAgICBwdWJsaWMgY29uc3RydWN0b3Iob3B0aW9uczogVnVsdHJleEhhc3RlT3B0aW9ucykge1xuICAgICAgICB0aGlzLnVybCA9IG9wdGlvbnMgPyBgJHtvcHRpb25zLnVybH0vZG9jdW1lbnRzYCA6IFwiaHR0cHM6Ly9oYXN0ZWJpbi5jb20vZG9jdW1lbnRzXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUE9TVCB0byBhIEhhc3RlYmluIFVSTCBhbmQgcmV0dXJuIHRoZSBVUkxcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfSBjb250ZW50IC0gVGhlIGNvbnRlbnQgb2Ygd2hhdCB5b3Ugd2lzaCB0byBwb3N0IHRvIEhhc3RlYmluXG4gICAgICogQHJldHVybnMgeyBzdHJpbmcgfSAtIFRoZSBVUkwgb2YgdGhlIGNyZWF0ZWQgSGFzdGVcbiAgICAgKiBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHsgVnVsdHJleEhhc3RlIH0gPSByZXF1aXJlKFwidnVsdHJleC5oYXN0ZVwiKTtcbiAgICAgKiBjb25zdCBoYXN0ZSA9IG5ldyBWdWx0cmV4SGFzdGUoeyB1cmw6IFwiaHR0cHM6Ly9oYXN0ZWJpbi5jb21cIiB9KTtcbiAgICAgKiBcbiAgICAgKiBoYXN0ZS5wb3N0KFwiTG9yZW0gaXBzdW1cIilcbiAgICAgKiAgICAgIC50aGVuKHVybCA9PiBjb25zb2xlLmxvZyh1cmwpKVxuICAgICAqICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhlcnIpKTtcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgcG9zdChjb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh0aGlzLnVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGJvZHk6IGNvbnRlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy51cmwuc2xpY2UoMCwgLTEwKX0vJHtqc29uLmtleX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXNUZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdFVCBmcm9tIGEgSGFzdGViaW4gVVJMIGFuZCByZXR1cm4gdGhlIGNvbnRlbnRcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBIYXN0ZVxuICAgICAqIEByZXR1cm5zIHsgc3RyaW5nIH0gLSBUaGUgY29udGVudCBvZiB0aGUgVVJMXG4gICAgICogXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCB7IFZ1bHRyZXhIYXN0ZSB9ID0gcmVxdWlyZShcInZ1bHRyZXguaGFzdGVcIik7XG4gICAgICogY29uc3QgaGFzdGUgPSBuZXcgVnVsdHJleEhhc3RlKCk7XG4gICAgICogXG4gICAgICogaGFzdGUuZ2V0KFwiaHR0cHM6Ly9oYXN0ZWJpbi5jb20vZm9yYWRvd3V0ZVwiKVxuICAgICAqICAgICAgLnRoZW4oY29udGVudCA9PiBjb25zb2xlLmxvZyhjb250ZW50KSlcbiAgICAgKiAgICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGdldCh1cmw6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgICAgIHJldHVybiByZXMudGV4dCgpO1xuICAgIH1cbn0iXX0=